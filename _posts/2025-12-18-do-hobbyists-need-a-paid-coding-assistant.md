---
title: Do Hobbyists Need a Paid Coding Assistant
date: 2025-12-18
categories:
  - views
tags:
  - llm
published: true
---
I’ve been using AI-assisted coding tools like Gravity, Cline, and Copilot for a while, and it keeps raising a question: as a hobbyist, do I really need them? There’s no denying their upside. They boost productivity, automate tedious work, and compressed the distance between an idea and a working prototype. But whether they belong in hobby projects depends entirely on intent.

If the goal is to learn new languages, architectures, or problem-solving skills, then leaning on AI actively works against that purpose. Basically you’re outsourcing the very struggle that builds competence. On the other hand, if the goal is to explore an idea, test a concept, or prototype something that would otherwise be too time-consuming or complex, AI tools are genuinely useful and often the right choice.

I built the initial concept of PyTBV without any AI help. I wrote every line myself, understood every decision, and knew exactly why the system behaved the way it did. That process gave me a strong sense of ownership, both of the code and of the idea behind it.

Later, I used Antigravity to extend PyTBV’s kernel. The progress was undeniably faster, but something shifted. The tool didn’t just assist; it started reshaping the codebase in its own way to satisfy my high-level intent. That isn’t inherently wrong. It sped up the proof of concept significantly. Still, it felt like part of the craftsmanship was outsourced. The code moved forward, but my sense of authorship weakened, as if some of the work had been done _for_ me rather than _by_ me.

I kept using Antigravity in other projects, but no longer as a coding partner. Instead, I used it to turn ideas directly into MVPs. That’s where I noticed a change in myself, I am getting lazy. I used to do the heavy lifting: research the problem space, read specifications, sketch designs, then translate all of that into code. Now the workflow is shorter and shallower. I draft a rough plan, feed in key constraints, review what comes back, challenge it, refine it, and once it looks reasonable, trigger the implementation.

The result is still satisfying when an MVP comes to life. But the codebase feels so unfamiliar. It works, yet it doesn’t feel _owned_. Reading it feels like browsing someone else’s repository which looks technically correct, but emotionally distant.

For me, being a hobbyist is ultimately about balancing satisfaction against outcomes. Some projects matter to me at a craft level when I want full ownership, deep understanding, and the quiet confidence that comes from knowing every corner of the code. In those cases, AI tools stay on the sidelines as reviewers, critics, or idea challengers, not authors.

Other times, I don’t care about the act of coding at all. I just want to see whether an idea works. In those cases, I’m happy to outsource the implementation entirely to AI tools, treating them like a development team while I play the role of the bossy customer who is setting requirements, reviewing results, and giving feedback.

The mistake is pretending one mode fits all. As a hobbyist, the real choice isn’t whether to use AI, but when to step in as the builder, and when to step back and just ask for the result. AI coding tools are neither a shortcut nor a threat, instead, they’re an amplifier. What they amplify depends entirely on intent. When learning and craftsmanship are the goal, delegating too much to AI strips away the struggle that creates understanding. When exploration and validation are the goal, insisting on manual implementation is just self-imposed friction.

The mature stance is being deliberate. Know when you want to _build_ and when you only want to _see_. Use AI as a reviewer when you care about authorship, and as an executor when you care about speed. Anything else is just sleepwalking into tools deciding how you work.

In the end, hobby projects aren’t about shipping, they’re about choosing what kind of satisfaction you’re optimizing for.