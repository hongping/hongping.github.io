---
title: Do Hobbyists Need a Paid Coding Assistant?
date: 2025-12-18
categories:
  - views
tags:
  - llm
published: false
---
I’ve been using AI-assisted coding tools like Gravity, Cline, and Copilot for a while, and it keeps raising a question: as a hobbyist, do I really need them? There’s no denying their upside. They boost productivity, automate tedious work, and compressed the distance between an idea and a working prototype. But whether they belong in hobby projects depends entirely on intent. If the goal is to learn new languages, architectures, or problem-solving skills, then leaning on AI actively works against that purpose. Basically you’re outsourcing the very struggle that builds competence. On the other hand, if the goal is to explore an idea, test a concept, or prototype something that would otherwise be too time-consuming or complex, AI tools are genuinely useful and often the right choice.

I built the initial concept of PyTBV without any AI help. I wrote every line myself, understood every decision, and knew exactly why the system behaved the way it did. That process gave me a strong sense of ownership, both of the code and of the idea behind it.

Later, I used Antigravity to extend PyTBV’s kernel. The progress was undeniably faster, but something shifted. The tool didn’t just assist; it started reshaping the codebase in its own way to satisfy my high-level intent. That isn’t inherently wrong. It sped up the proof of concept significantly. Still, it felt like part of the craftsmanship was outsourced. The code moved forward, but my sense of authorship weakened, as if some of the work had been done _for_ me rather than _by_ me.

I kept using Antigravity in other projects, but no longer as a coding partner. Instead, I used it to turn ideas directly into MVPs. That’s where I noticed a change in myself, I am getting lazy. I used to do the heavy lifting: research the problem space, read specifications, sketch designs, then translate all of that into code. Now the workflow is shorter and shallower. I draft a rough plan, feed in key constraints, review what comes back, challenge it, refine it, and once it looks reasonable, trigger the implementation.

The result is still satisfying when an MVP comes to life. But the codebase feels so unfamiliar. It works, yet it doesn’t feel _owned_. Reading it feels like browsing someone else’s repository which looks technically correct, but emotionally distant.